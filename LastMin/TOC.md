# Theory of Computation (TOC)

Theory of Computation (TOC) is the part of computer science that studies which problems computers can solve, how they solve them, and how efficiently they can do it. It includes concepts such as Finite Automata, Regular Expressions, Context-Free Grammars, and Turing Machines. These topics help in understanding computational problems and algorithms, and they form the foundation of problem-solving in computer science.

* Defines limits of computation, including undecidable problems like the Halting Problem.
* Studies abstract machines (FA, PDA, TM) to classify computational power and language hierarchies.
* Forms the foundation of parsers, compilers, and program verification.
* Helps analyse regular expressions, CFLs, and problems like P vs NP for algorithm design.
* Improves understanding of computability used in regex engines and AI parsers.

---

## Last Minute Notes - Theory of Computation - GeeksforGeeks

### Basics

#### 1. Symbol and Alphabet

* **Symbol**: A single character or entity, e.g., a, b, 1, 0.
* **Alphabet (Σ)**: A finite set of symbols, e.g., Σ = {a, b}.

#### 2. String

* **String**: A finite sequence of symbols from an alphabet, e.g., abba.
* **Empty String (ε)**: A string with no symbols.

#### 3. Operations on Strings

* **Concatenation**: Joining two strings.

  ```
  ```

w1 = ab, w2 = ba → w1.w2 = abba

```
- **Length (|w|)**: Number of symbols in a string.
```

|abba| = 4

```
- **Reverse (w^R)**: Reversing the order of symbols.
```

w = abba → w^R = abba

```

#### 4. Prefix, Suffix, and Substring
- **Prefix**: Any leading part of a string.
```

For w = abba, prefixes are {ε, a, ab, abb, abba}

```
- **Suffix**: Any trailing part of a string.
```

For w = abba, suffixes are {ε, a, ba, bba, abba}

```
- **Substring**: Any continuous part of a string.
```

For w = abba, substrings are {ε, a, b, ab, ba, bb, abb, bba, abba}

```

#### 5. Language
- **Language (L)**: A set of strings over an alphabet.
```

L = {w ∈ Σ* | w starts with a and ends with b}
For Σ = {a, b}, L = {ab, aab, abb, ...}

```

### Types of Languages
- **Finite Language**: Contains only a limited number of strings.
- **Infinite Language**: Contains an unlimited number of strings.
- **Regular Language**: Accepted by a Finite Automaton and represented using regular expressions.
- **DCFL (Deterministic CFL)**: Accepted by a Deterministic Pushdown Automaton (DPDA).
- **CFL**: Generated by a Context-Free Grammar (CFG) and accepted by a Pushdown Automaton.
- **CSL**: Generated by a Context-Sensitive Grammar and accepted by a Linear Bounded Automaton (LBA).
- **Recursive Language**: Decidable by a Turing Machine that halts on all inputs.
- **Recursive Enumerable Language (REL)**: Recognized by a Turing Machine; may not halt for strings not in the language.

### Relation Between Symbol, Alphabet, String, and Language
- **Symbol**: The smallest unit, e.g., a, b, 0, 1.
- **Alphabet (Σ)**: A finite set of symbols, e.g., Σ = {a, b}.
- **String**: A sequence of symbols from an alphabet, e.g., abba.
- **Language**: A set of strings over an alphabet, e.g., L = {ab, aab, abb}.

### Chomsky Hierarchy
- Defines the classification of languages based on generative power of grammars.
- Read more about Chomsky Hierarchy in TOC.

---

## Finite Automata (FA)

Finite Automata (FA) is a simple mathematical model used to represent and recognize regular languages.
- **FA = (Q, Σ, δ, q0 , F)**

### Types of FA
**Acceptor (Without Output)**
- DFA (Deterministic Finite Automaton)
- NFA (Non-Deterministic Finite Automaton)

**Transducer (With Output)**
- Moore Machine
- Mealy Machine

### Deterministic Finite Automata (DFA)
- Transition function: δ: Q × Σ → Q
- Maps a state and input symbol to a single next state.

### Non-Deterministic Finite Automata (NFA)
- **Without ε-moves**: δ: Q × Σ → 2^Q
- **With ε-moves**: δ: Q × (Σ ∪ {ε}) → 2^Q

**Notes:**
- Language accepted by NDFA and DFA are same.
- No. of states in NDFA ≤ no. of states in equivalent DFA.
- NFA with n states → max DFA states = 2^n.

### Steps to Construct DFA
1. Identify the input alphabet (Σ) and the states (Q).
2. Define initial and final states.
3. Create transition table ensuring every input symbol leads to exactly one state.
4. Ensure DFA accepts all strings of the language and rejects others.

### Steps to Construct NFA
1. Identify the pattern or condition the NFA should accept.
2. Create states for each stage of processing input.
3. Start from an initial state.
4. Define one or more final states based on acceptance criteria.
5. Allow multiple transitions for the same input symbol.
6. Include ε-transitions if needed.

### NFA to DFA Conversion
1. Convert NFA to equivalent transition table.
2. Create DFA’s start state.
3. Create DFA’s transition table.
4. Create DFA’s final states.
5. Simplify DFA.
6. Repeat steps 3–5 until no further simplification is possible.

### Minimization of DFA
- Steps include partitioning states, finding distinguishable states, merging sets, and obtaining minimized DFA.

### Moore and Mealy Machine
**Moore Machine:** Output depends on the state only.
```

Representation: M=(Q,Σ,Δ,δ,λ,q0)

```
**Mealy Machine:** Output depends on state and input.
```

Representation: M=(Q,Σ,Δ,δ,λ,q0)

```
Note: Mealy machines often require fewer states than Moore machines.

---

## Regular Expression (Regex)

Represents a regular language and describes a regular set.

**Operators:**
- **OR (|)**: a|b → {a, b}
- **Concatenation (.)**: ab → {ab}
- **Kleene Star (*)**: a* → {ε, a, aa, aaa, ...}
- **Kleene Plus (+)**: a+ → {a, aa, aaa, ...}

### Identification of Regular Languages
- Finite languages are always regular.
- Infinite languages are regular if they follow patterns.

### Pumping Lemma Test
Used to prove a language is not regular.
- String w = xyz
- xy^i z ∈ L for all i ≥ 0
- |y| > 0, |xy| ≤ p

### Arden's Theorem
- Solves regular expression equations R = Q + RP.
- Solution: R = QP* if P does not contain ε.

### Regular Grammar
- Generates regular languages.
- Right-Linear Grammar: A→aB or A→a
- Left-Linear Grammar: A→Ba or A→a

---

## Context-Free Grammar (CFG)

- **Definition**: Productions of the form V → (V ∪ T)*
- **Linear Derivation**: Left Most Derivation (LMD), Right Most Derivation (RMD)
- **Non-Linear Derivation**: Parse Tree or Derivation Tree

### Types of CFG
- Ambiguous Grammar
- Unambiguous Grammar
- Left-Recursive Grammar
- Right-Recursive Grammar
- Regular Grammar

---

## Push Down Automata (PDA)
- Extends FA using stack memory.
- Recognizes Context-Free Languages (CFLs).

### Types of PDA
1. **Deterministic PDA (DPDA)**: Recognizes DCFL.
2. **Non-Deterministic PDA (NPDA)**: Recognizes all CFLs.

**Key Differences:**
| Feature | DPDA | NPDA |
|---------|------|------|
| Language Recognized | DCFL | CFL |
| Transitions | Single | Multiple |
| Ambiguity | Cannot handle | Can handle |

**Closure Properties:** See table in text.

---

## Turing Machine (TM)

- **Definition**: Mathematical model to define computation.
- **Components**: Q, Σ, Γ, δ, q0, q_accept, q_reject
- **Types**: DTM, NTM, Multi-Tape TM, Multi-Track TM, Universal TM
- **Church-Turing Thesis**: Any computation by mechanical process can be simulated by TM.
- **Time Complexity**: DTM O(f(n)), NTM O(2^O(f(n)))

### Recursive and Recursively Enumerable Languages
- **Recursive Language**: TM halts on every input.
- **Recursively Enumerable (RE) Language**: TM halts for inputs in language; may loop otherwise.

### Complement Property
- Complement of Recursive = Recursive
- Complement of RE = Recursive or non-RE

### Closure Properties of RE and Rec Languages
- See table in text.

### Decidable and Undecidable Problems
- **Decidable**: TM exists and halts on all inputs.
- **Undecidable**: No TM exists for all inputs.
  - RE but not Recursive
  - Not RE

### Countability in Turing Machines
- **Countable Set**: All Turing Machines.
- **Uncountable Set**: All possible languages.

```
